

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux Device Model &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/asciinema-player.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Virtual Machine Setup" href="../info/vm.html" />
    <link rel="prev" title="Memory mapping" href="memory_mapping.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Lectures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/so2.cs.pub.ro.html">Sisteme de operare 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">System Calls</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
</ul>
<p class="caption"><span class="caption-text">Labs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linux Device Model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sysfs">sysfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-structures-in-linux-devices">Basic Structures in Linux Devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-kobject-structure">The kobject structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buses">Buses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#devices">Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#drivers">Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hotplug">Hotplug</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plug-and-play">Plug and Play</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pnp-bus">PNP bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pnp-operations">PNP operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#add-driver">Add driver</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#intro">0. Intro</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bus-implementation">1. Bus implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#add-type-and-version-device-attributes">2. Add type and version device attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#add-del-and-add-bus-attributes">3. Add del and add bus attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-the-bex-misc-driver">4. Register the bex misc driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-misc-device-in-the-bex-misc-probe-function">5. Register misc device in the bex_misc probe function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monitor-uevent-notifications">6. Monitor uevent notifications</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Useful info</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">Contributing to linux-kernel-labs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Linux Device Model</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/labs/device_model.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-device-model">
<h1>Linux Device Model<a class="headerlink" href="#linux-device-model" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Plug and Play is a technology that offers support for automatically adding and
removing devices to your system. This reduces conflicts with the resources they
use by automatically configuring them at system startup. In order to achieve
these goals, the following features are required:</p>
<blockquote>
<div><ul class="simple">
<li>Automatic detection of adding and removing devices in the system (the  device
and its bus must notify the appropriate driver that a configuration change
occurred).</li>
<li>Resource management (addresses, irq lines, DMA channels, memory areas),
including resource allocation to devices and solving conflicts that may arise.</li>
<li>Devices must allow for software configuration (device resources - ports,
interrupts, DMA resources - must allow for driver assignment).</li>
<li>The drivers required for new devices must be loaded automatically by the
operating system when needed.</li>
<li>When the device and its bus allow, the system should be able to add or
remove the device from the system while it is running, without having to reboot
the system ( hotplug ).</li>
</ul>
</div></blockquote>
<p>For a system to support plug and play, the BIOS , operating system and device
must support this technology. The device must have an ID that will provide the
driver for identification, and the operating system must be able to identify
these configuration changes as they appear.</p>
<p>Plug and play devices are: PCI devices (network cards), USB (keyboard, mouse,
printer), etc.</p>
<p>Prior to version 2.6, the kernel did not have a unified model to get
information about it. For this reason, a model for Linux devices, Linux Device
Model, was developed.</p>
<p>The primary purpose of this model is to maintain internal data structures that
reflect the state and structure of the system. Such information includes what
devices are in the system, how they are in terms of power management, what bus
they are attached to, what drivers they have, along with the structure of the
buses, devices, drivers in the system.</p>
<p>To maintain this information, the kernel uses the following entities:</p>
<blockquote>
<div><ul class="simple">
<li>device - a physical device that is attached to a bus</li>
<li>driver - a software entity that can be associated with a device and performs
operations with it</li>
<li>bus - a device to which other devices can be attached</li>
<li>class - a type of device that has a similar behavior; There is a class for
discs, partitions, serial ports, etc.</li>
<li>subsystem - a view on the structure of the system; Kernel subsystems
include devices (hierarchical view of all devices in the system), buses (bus
view of devices according to how they are attached to buses), classes, etc.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="sysfs">
<h2>sysfs<a class="headerlink" href="#sysfs" title="Permalink to this headline">¶</a></h2>
<p>The kernel provides a representation of its model in userspace through the
sysfs virtual file system. It is usually mounted in the /sys directory and
contains the following subdirectories:</p>
<blockquote>
<div><ul class="simple">
<li>block - all block devices available in the system (disks, partitions)</li>
<li>bus - types of bus to which physical devices are connected (pci, ide, usb)</li>
<li>class - drivers classes that are available in the system (net, sound, usb)</li>
<li>devices - the hierarchical structure of devices connected to the system</li>
<li>firmware - information from system firmware (ACPI)</li>
<li>fs - information about mounted file systems</li>
<li>kernel - kernel status information (logged-in users, hotplug)</li>
<li>modules - the list of modules currently loaded</li>
<li>power - information related to the power management subsystem</li>
</ul>
</div></blockquote>
<p>As you can see, there is a correlation between the kernel data structures
within the described model and the subdirectories in the sysfs virtual file
system. Although this likeness may lead to confusion between the two concepts,
they are different. The kernel device model can work without the sysfs file
system, but the reciprocal is not true.</p>
<p>The sysfs information is found in files that contain an attribute. Some
standard attributes (represented by files or directories with the same name)
are as follows:</p>
<blockquote>
<div><ul class="simple">
<li>dev - Major and minor device identifier. It can be used to automatically
create entries in the /dev directory</li>
<li>device - a symbolic link to the directory containing devices; It can be
used to discover the hardware devices that provide a particular service (for
example, the ethi PCI card)</li>
<li>driver - a symbolic link to the driver directory (located in
/sys/bus/*/drivers )</li>
</ul>
</div></blockquote>
<p>Other attributes are available, depending on the bus and driver used.</p>
</div>
<div class="section" id="basic-structures-in-linux-devices">
<h2>Basic Structures in Linux Devices<a class="headerlink" href="#basic-structures-in-linux-devices" title="Permalink to this headline">¶</a></h2>
<p>Linux Device Model provides a number of structures to ensure the interaction
between a hardware device and a device driver. The whole model is based on
kobject structure. With this structure, hierarchies are built and the following
structures are implemented:</p>
<blockquote>
<div><ul class="simple">
<li>structure bus_type</li>
<li>struct device</li>
<li>struct device_driver</li>
</ul>
</div></blockquote>
<div class="section" id="the-kobject-structure">
<h3>The kobject structure<a class="headerlink" href="#the-kobject-structure" title="Permalink to this headline">¶</a></h3>
<p>A kobject structure does not perform a single function. Such a structure is
usually integrated into a larger structure. A kobject structure actually
incorporates a set of features that will be offered to a higher abstraction
object in the Linux Device Model hierarchy.</p>
<p>For example, the cdev structure has the following definition:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span> <span class="k">struct</span> <span class="n">cdev</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span> <span class="n">owner</span> <span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span> <span class="n">ops</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span> <span class="p">;</span>
        <span class="kt">dev_t</span> <span class="n">dev</span> <span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>Note that this structure includes a kobject structure field.</p>
<p>A kobject structure structure is defined as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span> <span class="k">struct</span> <span class="n">kobject</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span> <span class="n">parent</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span> <span class="n">kset</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobj_type</span> <span class="o">*</span> <span class="n">ktype</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">sysfs_dirent</span> <span class="o">*</span> <span class="n">sd</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span> <span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_initialized</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_in_sysfs</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_add_uevent_sent</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_remove_uevent_sent</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">uevent_suppress</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As we can see, the kobject structures are in a hierarchy : an object has a
parent and holds a kset member, which contains objects on the same level.</p>
<p>Working with the structure involves initializing it with the kobject_init
function. Also in the initialization process it is necessary to establish the
name of the kobject structure, which will appear in sysfs, using the
kobject_set_name function.</p>
<p>Any operation on a kobject is done by incrementing its internal counter with
kobject_get, or decrementing if it is no longer used with kobject_put . Thus,
a kobject object will only be released when its internal counter reaches 0. A
method of notifying this is needed so that the resources associated with the
device structure are released Included kobject structure (for example, cdev ).
The method is called release and is associated with the object via the ktype
field (struct kobj_type).</p>
<p>The kobject structure structure is the basic structure of the Linux Device
Model. The structures in the higher levels of the model are struct bus_type ,
struct device and struct device_driver .</p>
</div>
<div class="section" id="buses">
<h3>Buses<a class="headerlink" href="#buses" title="Permalink to this headline">¶</a></h3>
<p>A bus is a communication channel between the processor and an input / output
device. To ensure that the model is generic, all input / output devices are
connected to the processor via such a bus (even if it can be a virtual one
without a physical hardware correspondent).</p>
<p>When adding a system bus, it will appear in the sysfs file system in /sys/bus
As with kobjects, buses can be organized into hierarchies and will be represented
in sysfs.</p>
<p>In the Linux Device Model, a bus is represented by the struct bus_type:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev_root</span> <span class="p">;</span>
        <span class="k">struct</span> <span class="n">bus_attribute</span> <span class="o">*</span><span class="n">bus_attrs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">dev_attrs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">driver_attribute</span> <span class="o">*</span><span class="n">drv_attrs</span><span class="p">;</span>
        <span class="n">structure</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)</span> <span class="p">(</span><span class="n">device</span> <span class="n">structure</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">uevent</span><span class="p">)</span> <span class="p">(</span><span class="n">structure</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)</span> <span class="p">(</span><span class="n">device</span> <span class="n">structure</span> <span class="o">*</span> <span class="n">dev</span><span class="p">);</span>
        <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It is noticed that a bus is associated with a name, lists of default
attributes, a number of specific functions, and the driver’s private data. The
uevent function (formerly hotplug) is used with hotplug devices.</p>
<p>Bus operations are the registration operations, the implementation of the
operations described in the bus_type structure structure and the scrolling and
inspection operations of the devices connected to the bus.</p>
<p>Recording a bus is done using bus_register , and registering using bus_unregister.</p>
<p>Show example implementation</p>
<p>The functions that will normally be initialized within a bus_type structure are
match and uevent :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;linux/device.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;linux/string.h&gt;</span><span class="cp"></span>

<span class="cm">/* match devices to drivers;  Just do a simple name test */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_match</span> <span class="p">(</span><span class="n">structure</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  respond to hotplug user events;  Add environment variable DEV_NAME */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;DEV_NAME =% s&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
   <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The match function is used when a new device or a new driver is added to the
bus. Its role is to make a comparison between the device ID and the driver ID.
The uevent function is called before generating a hotplug in user-space and has
the role of adding environment variables.</p>
<p>Other possible operations on a bus are browsing the drivers or devices attached
to it. Although we can not directly access them (lists of drives and devices
being stored in the private data of the driver, the subsys_private * p field ),
these can be scanned using the bus_for_each_dev and bus_for_each_drv
macrodefines .</p>
<p>The Linux Device Model interface allows you to create attributes for the
associated objects. These attributes will have a corresponding file in the
subdirectory of the sysfs bus. The attributes associated with a bus are
described by the bus_attribute structure :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bus_attribute</span> <span class="p">{</span>
        <span class="n">attribute</span> <span class="n">attribute</span> <span class="n">attr</span> <span class="p">;</span>
        <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
        <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Typically, an attribute is defined by the BUS_ATTR macrodefine . To add /
delete an attribute within the bus structure, the bus_create_file and
bus_remove_file functions are used.</p>
<p>An example of defining an attribute for my_bus is shown below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">del_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
     <span class="kt">int</span> <span class="n">version</span><span class="p">;</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
             <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

     <span class="k">return</span> <span class="n">bex_del_dev</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">del</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">del_store</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">bex_bus_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
     <span class="o">&amp;</span><span class="n">bus_attr_add</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
     <span class="o">&amp;</span><span class="n">bus_attr_del</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
     <span class="nb">NULL</span>
<span class="p">};</span>
<span class="n">ATTRIBUTE_GROUPS</span><span class="p">(</span><span class="n">bex_bus</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">bex_bus_type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">.</span><span class="n">bus_groups</span> <span class="o">=</span> <span class="n">bex_bus_groups</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The bus is represented by both a bus_type object and a device object, as we
will see later (the bus is also a device).</p>
</div>
<div class="section" id="devices">
<h3>Devices<a class="headerlink" href="#devices" title="Permalink to this headline">¶</a></h3>
<p>Any device in the system has a struct structure structure associated with it.
Devices are discovered by different kernel methods (hotplug, device drivers,
system initialization) and are recorded in the system. All devices present in
the kernel have an entry in /sys/devices .</p>
<p>At the bottom level, a device in Linux Device Model is a struct structure
device :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">device</span> <span class="p">{</span>

      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span> <span class="p">;</span>
      <span class="k">struct</span> <span class="n">device_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>

      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init_name</span><span class="p">;</span>  <span class="cm">/* Initial name of the device */</span>

      <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span> <span class="p">;</span>  <span class="cm">/* Type of bus device is on */</span>
      <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="p">;</span>  <span class="cm">/* Which driver has assigned this Device */</span>

      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Structure fields include the parent device that is usually a controller, the
associated kobject object, the bus it is located on, the device driver, and a
called function when the device counter reaches 0.</p>
<p>As usual, we have registration_registration / registration functions
device_register and device_unregister.</p>
<p>To work with the attributes, we have structure structure_atribute_attribute ,
DEVICE_ATTR macrodefine for definition, and device_create_file and
device_remove_file functions to add the attribute to the device.</p>
<p>One important thing to note is that it usually does not work directly with a
struct device structure, but with a structure that contains it, like:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* my device type */</span>
 <span class="k">struct</span> <span class="n">my_device</span> <span class="p">{</span>
       <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span> <span class="p">;</span>
       <span class="k">struct</span> <span class="n">my_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
       <span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>Typically, a bus driver will export function to add or remove such a
device, as shown below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">bex_add_dev</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">version</span><span class="p">)</span>
<span class="p">{</span>
     <span class="k">struct</span> <span class="n">bex_device</span> <span class="o">*</span><span class="n">bex_dev</span><span class="p">;</span>

     <span class="n">bex_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bex_dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bex_dev</span><span class="p">)</span>
             <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

     <span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
     <span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="p">;</span>

     <span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bex_bus_type</span><span class="p">;</span>
     <span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bex_device_type</span><span class="p">;</span>
     <span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

     <span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

     <span class="k">return</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">bex_del_dev</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

     <span class="n">dev</span> <span class="o">=</span> <span class="n">bus_find_device_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bex_bus_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
             <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

     <span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
     <span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="drivers">
<h3>Drivers<a class="headerlink" href="#drivers" title="Permalink to this headline">¶</a></h3>
<p>Linux Device Model is used to allow very easy association between system
devices and drivers. Drivers can export information independent of the physical
device.</p>
<p>In sysfs driver information has no single subdirectory associated; They can be
found in the directory structure in different places: in the /sys/module there
is the loaded module, in the devices you can find the driver associated with
each device, in the classes belonging to the drivers in the /sys/bus drivers
associated to each bus .</p>
<p>A device driver is identified by the structure structure of device_driver :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">device_driver</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="n">structure</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">driver_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

        <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">;</span>  <span class="o">/</span> <span class="o">*</span> <span class="n">Used</span> <span class="k">for</span> <span class="n">built</span><span class="o">-</span><span class="n">in</span> <span class="n">modules</span> <span class="o">*</span> <span class="o">/</span>

        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span> <span class="p">(</span><span class="n">structure</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span> <span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span> <span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span> <span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Among the structure fields we find the name of the driver (appears in sysfs ),
the bus with which the driver works, and functions called at various times in a
device’s operation.</p>
<p>As before, we have the registration / registration functions of driver_register
and driver_unregister .</p>
<p>To work with attributes, we have the driver_attribute structure , the macro
definition of DRIVER_ATTR for definition, and the driver_create_file and
driver_remove_file functions for adding the attribute to the device.</p>
<p>As with devices, the device_driver structure structure is usually incorporated
into another structure specific to a particular bus (PCI, USB, etc.):</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bex_driver</span> <span class="p">{</span>
     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>

     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bex_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bex_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

     <span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Driver registration / registration operations are exported for use in
other modules:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bex_driver</span> <span class="n">bex_misc_driver</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;misc&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">bex_misc_probe</span><span class="p">,</span>
    <span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">bex_misc_remove</span><span class="p">,</span>
    <span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bex_misc&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="cm">/* register driver */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">bex_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bex_misc_driver</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="cm">/* unregister driver */</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">bex_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bex_misc_driver</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<p>A class is a high-level view of the Linux Device Model, which abstracts
implementation details. For example, there are drivers for SCSI and ATA
drivers, but all belong to the class of drives. Classes provide a grouping of
devices based on functionality, not how they are connected or how they work.
Classes have a correspondent in /sys/classes.</p>
<p>There are two main structures that describe the classes: struct class and
struct device . The class structure describes a generic class, while the
structure struct device describes a class associated with a device. There are
functions for initializing / deinitiating and adding attributes for each of
these, include/linux/device.h in include/linux/device.h.</p>
<p>The advantage of using classes is that the udev program in userspace, which we
will discuss later, allows the automatic creation of devices in the /dev
directory based on class information.</p>
<p>For this reason, we will continue to present a small set of functions that work
with classes to simplify the use of the plug and play mechanism.</p>
<p>A generic class is described by structure class structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span> <span class="k">struct</span> <span class="n">class</span> <span class="p">{</span>
         <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span> <span class="p">;</span>
         <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span> <span class="p">;</span>
         <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">dev_kobj</span> <span class="p">;</span>

         <span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">class_attrs</span> <span class="p">;</span>
         <span class="k">struct</span> <span class="n">class_device_attribute</span> <span class="o">*</span><span class="n">class_dev_attrs</span> <span class="p">;</span>
         <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">dev_attrs</span> <span class="p">;</span>

         <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_uevent</span><span class="p">)</span> <span class="p">(</span><span class="n">structure</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span> <span class="n">env</span><span class="p">);</span>
         <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">class_release</span><span class="p">)</span> <span class="p">(</span><span class="n">class</span> <span class="n">class</span> <span class="o">*</span> <span class="n">class</span><span class="p">)</span> <span class="p">;</span>
         <span class="kt">void</span> <span class="p">(</span> <span class="n">dev_release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">;</span>
         <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class_register and class_unregister functions for initialization /
and cleanup :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">my_class</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;myclass&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* handle error */</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_cleanup</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A class associated with a device is described by the device structure. The
device_create and device_destroy functions are available for initialization /
deinterlacing . The device_create function initializes the device structure,
associates its generic class structure with the received device as a parameter;
In addition, it will create an attribute of the class, dev , which contains the
minor and major of the device ( minor:major ). Thus, udev utility in usermode
can read the necessary data from this attribute file to create a node in the
/dev makenod by calling makenod .</p>
<p>An example of initialization:</p>
<dl class="docutils">
<dt>..code-block:: c</dt>
<dd><p class="first">struct device * my_classdev ;
cdev cdev struct ;
struct device dev ;</p>
<p>// init class for device cdev.dev
my_classdev = device_create (&amp;my_class, NULL, cdev.dev, &amp;dev, “myclass0”);</p>
<p class="last">// destroy class for device cdev.dev
device_destroy (&amp;my_class, cdev.dev);</p>
</dd>
</dl>
<p>When a new device is discovered, a class and a node will be assigned to the
/dev directory. For the example above, a /dev/myclass0 node will be
/dev/myclass0.</p>
</div>
<div class="section" id="hotplug">
<h3>Hotplug<a class="headerlink" href="#hotplug" title="Permalink to this headline">¶</a></h3>
<p>Hotplug describes the mechanism for adding or removing a device from the system
while it is running without having to reboot the system.</p>
<p>A hotplug is a notification from the kernel to the user-space when something
changes in the system configuration. These events are generated when creating
or removing a kobject from the kernel. Since these objects are the basis of the
Linux Device Model, they are included in all structures(struct bus_type,
struct device, struct device_driver, struct class, etc.), a hotplug event
will be created to create or remove any of these structures ( uevent ). When a
device is discovered in the system, an event is generated. Depending on the
point in the Linux Device Model , the functions associated with the occurrence
of an event (usually the case of the bus or class uevent function) are called.
The driver has the ability to set system variables for user-space through these
functions. The generated event reaches the user-space then. Here is the udev
utility that captures these events. There are configuration files for this
utility in the /etc/udev/ directory. Different rules can be specified to
capture only certain events and perform certain actions, depending on the
system variables set in the kernel or in uevent uevent .</p>
<p>An important consequence is that in this way the plug and play mechanism can be
achieved;with his help udevand classes described above may automatically create
entries in the directory /devdevice, and using udevit can automatically load
necessary drivers for a device. In this way, the entire process is automated.</p>
<p>Rules udevare located /etc/udev/rules.d. Any file that ends with .conf here
will be parsed when an event occurs. For more details on how to write rules in
these files see Writing udev rules . For testing, there are utilities
udevmonitor, udevinfoand udevtest.</p>
<p>For a quick example, consider the situation where we want to automatically load
a driver for a device at the time of an event. We can create a new file
/etc/udev/rules.d/myrules.rules, we will have the following line:</p>
<p>Subsystem == “PNP” , attrs {  id  } == “PNP0400” , RUN + = “/ sbin / insmod
/root/mydriver.ko”</p>
<p>This will choose between events generated only those belonging subsystem
pnp(connected to bus PNP) and an id attribute value PNP0400. When will find
this rule will execute the command that inserts the appropriate driver in the
kernel.</p>
</div>
<div class="section" id="plug-and-play">
<h3>Plug and Play<a class="headerlink" href="#plug-and-play" title="Permalink to this headline">¶</a></h3>
<p>As noted above, Linux Device Model all devices are connected by a bus, even if
it has the corresponding physical or virtual hardware.</p>
<p>The kernel is already implemented most buses by defining a structure bus_type
and recording functions / Unregistering drivers and appliances. To implement a
bus driver to be determined attaching supported devices and also used its
structures and functions. The main highways are PCI , USB , PNP , IDE , SCSI ,
platform , ACPI , etc.</p>
</div>
<div class="section" id="pnp-bus">
<h3>PNP bus<a class="headerlink" href="#pnp-bus" title="Permalink to this headline">¶</a></h3>
<p>Plug and play mechanism provides a means of detecting and setting the resources
for legacy driver that may not be configured or otherwise. All plug and play
drivers, protocols, services based on level Plug and Play. It is responsible
for the exchange of information between drivers and protocols. The following
protocols are available:</p>
<blockquote>
<div>PNPBIOS - used for systems such as serial and parallel ports
ISAPNP - supports ISA bus
ACPI - offering, among other things, information about system-level devices</div></blockquote>
<p>The kernel there is a bus pnp_busthat is used to connect many drivers.
Implementation and working with the bus follow the model Linux Device Modeland
is very similar to what thus far.</p>
<p>Main functions and structures exported by the bus, and can be used by drivers
are:</p>
<blockquote>
<div>pnp_driver type associated bus driver
pnp_register_driver to record a PNP driver system
pnp_unregister_driver to deînregistra a PNP driver system</div></blockquote>
<p>As noted in previous sections, the bus has a function matchwith which the
devices associated with the appropriate drivers. For example, if a device
discovery will search for the driver who satisfies the condition given by the
function for the device. Usually this condition is a comparison of IDs and
device driver. One mechanism is to use a static tables spread each driver,
containing information about supported devices and driver bus will be used for
comparison. For example, a parallel port driver will be making
parport_pc_pnp_tbl:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">parport_pc_pnp_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
         <span class="cm">/* Standard LPT Printer Port */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0400&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
         <span class="cm">/* ECP Printer Port */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0401&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span><span class="n">parport_pc_pnp_tbl</span><span class="p">);</span>
</pre></div>
</div>
<p>It declares and initializes a structure pnp_driver such as
parport_pc_pnp_driver:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">parport_pc_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                                 <span class="k">const</span>  <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">card_id</span><span class="p">,</span>
                                 <span class="k">const</span>  <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span> <span class="p">;</span>

 <span class="k">static</span>  <span class="kt">void</span> <span class="nf">parport_pc_pnp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">;</span>

<span class="k">static</span>  <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">parport_pc_pnp_driver</span> <span class="o">=</span>  <span class="p">{</span>
          <span class="p">.</span><span class="n">name</span>  <span class="o">=</span>  <span class="s">&quot;parport_pc&quot;</span><span class="p">,</span>
          <span class="p">.</span><span class="n">id_table</span>  <span class="o">=</span> <span class="n">parport_pc_pnp_tbl</span><span class="p">,</span>
          <span class="p">.</span><span class="n">samples</span>  <span class="o">=</span> <span class="n">parport_pc_pnp_probe</span><span class="p">,</span>
          <span class="p">.</span><span class="n">remove</span>  <span class="o">=</span> <span class="n">parport_pc_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As can be seen, the structure has as parameters a pointer to the table above
stated two functions is called a detection device or to remove it from the
system. Like all layouts, the driver must be registered in the system:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span>  <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parport_pc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">err</span> <span class="o">=</span> <span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_pc_pnp_driver</span><span class="p">);</span>
      <span class="k">if</span>  <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
              <span class="o">/</span> <span class="o">*</span> <span class="n">handle</span> <span class="n">error</span> <span class="o">*</span> <span class="o">/</span>
       <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span>  <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">parport_pc_exit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_pc_pnp_driver</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pnp-operations">
<h3>PNP operations<a class="headerlink" href="#pnp-operations" title="Permalink to this headline">¶</a></h3>
<p>So far we have discussed the model Linux Device Modeland API CPC used. To
implement a driver plug and play, must be respected model Linux Device Model.</p>
<p>Most often, adding a main kernel is not necessary (bus), as already implemented
most highways ( PCI, USB, etc.). The first to be identified that is attached to
the device bus. In the examples below, we believe that this bus is bus PNP.
Thus, use of the above structures and functions.</p>
</div>
<div class="section" id="add-driver">
<h3>Add driver<a class="headerlink" href="#add-driver" title="Permalink to this headline">¶</a></h3>
<p>In addition to the usual operations, a driver must obey Linux Device Model.
This will register in the system using functions provided by bus for this
purpose. Usually, the bus provides the driver a particular structure containing
a structure device_driver , that driver must initialize and record a function
*_register_driver. For example, the bus PNPdriver must declare and initialize a
structure type pnp_driver which to register with pnp_register_driver :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span>  <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span>  <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="s">&quot;mydriver&quot;</span><span class="p">,</span>
        <span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">my_pnp_tbl</span><span class="p">,</span>
        <span class="p">.</span><span class="n">samples</span>  <span class="o">=</span> <span class="n">my_pnp_probe</span><span class="p">,</span>
        <span class="p">.</span><span class="n">remove</span>   <span class="o">=</span> <span class="n">my_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span>  <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">err</span> <span class="o">=</span> <span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pnp_driver</span> <span class="p">)</span>  <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unlike legacy drivers, drivers, plug and play device initialization is not
recorded in the position my_init( register_device). As described above, each
bus has a function matchwhich is called when an associated manager application
to determine its driver. Therefore, there must be a way for each driver to
export information about which devices support in order to pass this comparison
and to be called his functions. In the examples shown in the laboratory to make
a simple comparison between the device name and driver name. Most drivers use a
table with information about the device, for which a structure pointer in the
driver. For example, one associated with a bus driver PNP, a table declares the
type pnp_device_id , and initializes the field id_tableof structure pnp_driver
with a pointer to it:</p>
<p>In the example above driver support parallel port operations. This information
is used by bus in function match_device. When adding a driver, bus driver will
assign and create entries sysfsbased on the driver name. Then call the function
matchbus for all devices associated to associate the driver with any connected
device that supports it.
Remove driver</p>
<p>To remove a driver in the kernel, in addition to operations required a legacy
driver must deînregistrată device_driver structure. If a bus driver for a
paired device PNP, it deînregistrată structure pnp_driver by using the tool
pnp_unregister_driver :</p>
<p>Unlike legacy drivers, plug and play drivers deînregistrează not
Unregistering driver devices to the function my_exit(unregister_device). When
you remove a driver, will remove all references to it for all devices it
supports and also deletes entries sysfs.
Add device</p>
<p>As we saw above, plug and play drivers do not register initialization devices.
This operation will take the position probethat will appeal to a detection
device. In the case of a driver for a device attached to the bus PNP, the
addition will be carried out in function probeof the structure pnp_driver :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">my_pnp_probe</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span>
                         <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">card_id</span><span class="p">,</span>
                         <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">iobase</span><span class="p">,</span> <span class="n">nr_ports</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>

        <span class="c1">//get irq &amp; ports</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pnp_irq_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">irq</span> <span class="o">=</span> <span class="n">pnp_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pnp_port_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">iobase</span> <span class="o">=</span> <span class="n">pnp_port_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
        <span class="n">nr_ports</span> <span class="o">=</span> <span class="n">pnp_port_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="cm">/* register device dev */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">my_pnp_probe</span><span class="p">,</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Upon detection of a device in the kernel (in the boot or by the addition of the
device hotplug), it transmits an interrupt to get to the bus system. The device
is recorded with the device_register and is attached to the bus (and will
generate a call userspace, which can be detected udev). Then will cycle through
the bus drivers and will call the function matchfor each of them. Function
matchtries to associate a driver with a device. After being determined
associated device driver will call the function probeof the driver. If the
function ends successfully, the device is added to the list of devices the
driver and creates corresponding entries sysfsbased on the device name.
Remove device</p>
<p>As we saw above, drivers deînregistrează not plug and play devices to
Unregistering driver. This operation will take the position removethat will
appeal to eliminate detection device in the kernel. In the case of a driver for
a device attached to the bus PNP, the addition will be carried out in function
removeof the structure pnp_driver :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">my_pnp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
         <span class="cm">/* unregister device dev */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">my_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As can be seen, the detection device disposal system will call the function
remove the driver will generate a call in user space, which can be detected
udevand dispose entries sysfs.</p>
</div>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is device_model. See the exercises for the task name.</p>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code for a complete lab:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>You can also generate the skeleton for a single task, using</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>Once the skeleton drivers are generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/device_model/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">Connecting to the VM</span></a>.</p>
<p class="last">Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Before starting the exercises or generating the skeletons, please run <strong>git pull</strong> inside the Linux repo,
to make sure you have the latest version of the exercises.</p>
<p>If you have local changes, the pull command will fail. Check for local changes using <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code>.
If you want to keep them, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code> before <code class="docutils literal"><span class="pre">pull</span></code> and <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code> after.
To discard the changes, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>.</p>
<p class="last">If you already generated the skeleton before <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> you will need to generate it again.</p>
</div>
<div class="section" id="intro">
<h3>0. Intro<a class="headerlink" href="#intro" title="Permalink to this headline">¶</a></h3>
<p>Find the definitions of the following symbols in the Linux kernel:</p>
<blockquote>
<div><ul class="simple">
<li>dev_name, dev_set_name</li>
<li>pnp_device_probe, pnp_bus_match , pnp_register_driver and pnp_bus_type</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="bus-implementation">
<h3>1. Bus implementation<a class="headerlink" href="#bus-implementation" title="Permalink to this headline">¶</a></h3>
<p>Analyze the contents of the <strong>bex.c</strong>, a modul that implements a bus
driver. Implement the missing functionality marked by <strong>TODO 1</strong>:
register the bus driver and add a new device named “root” with the
type “none” and version 1.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">See <code class="xref c c-func docutils literal"><span class="pre">bex_add_dev()</span></code>.</p>
</div>
<p>Load the module and verify that the bus is visible in /sys/bus. Verify
that the device is visible int /sys/bus/bex/devices.</p>
<p>Remove the module and notice that the sysfs entries are removed.</p>
</div>
<div class="section" id="add-type-and-version-device-attributes">
<h3>2. Add type and version device attributes<a class="headerlink" href="#add-type-and-version-device-attributes" title="Permalink to this headline">¶</a></h3>
<p>Add two read-only device attributes, type and version. Follow the
<strong>TODO 2</strong> markings.</p>
<p>Observe that two new attributes are visible in
/sys/bus/bex/devices/root. Check the contents of these attributes.</p>
</div>
<div class="section" id="add-del-and-add-bus-attributes">
<h3>3. Add del and add bus attributes<a class="headerlink" href="#add-del-and-add-bus-attributes" title="Permalink to this headline">¶</a></h3>
<p>Add two write-only bus attributes, del and add. del expects the name
of a device to delete, while add expects the name, type and version to
create a new device. Follow the <strong>TODO 3</strong> markings and review
<a class="reference internal" href="#buses">Buses</a>.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use <code class="xref c c-func docutils literal"><span class="pre">sscanf()</span></code> to parse the input from sysfs and
<code class="xref c c-func docutils literal"><span class="pre">bex_del_dev()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">bex_add_dev()</span></code> to delete
and create a new device.</p>
</div>
<p>Create a new device and observe that is visible in
/sys/bus/devices. Delete it and observe it disapears from sysfs.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>Use echo to write into the bus attributes:</p>
<div class="last highlight-shell"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> <span class="s2">&quot;name type 1&quot;</span> &gt; /sys/bus/bex/add

$ <span class="nb">echo</span> <span class="s2">&quot;name&quot;</span> &gt; /sys/bus/bex/del
</pre></div>
</div>
</div>
</div>
<div class="section" id="register-the-bex-misc-driver">
<h3>4. Register the bex misc driver<a class="headerlink" href="#register-the-bex-misc-driver" title="Permalink to this headline">¶</a></h3>
<p>Modify <strong>bex-misc.c</strong> so that it registers the driver with the bex
bus. Insert the bmx_misc.ko module and create a new bex device from
sysfs with the name “test”, type “misc”, version 2. Follow the <strong>TODO
4</strong> markings.</p>
<p>Observe that the driver is visible in /sys/bus/bex/drivers.</p>
<p>Why isn’t the probe function called?</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">notice that the bus match function in <strong>bex.c</strong> is not
implemented.</p>
</div>
<p>Implemet the bus matching function in <strong>bex.c</strong>. Follow the <strong>TODO 5</strong>
markings. Try again to create a new bex device and observ that this
time the bex_misc probe function is called.</p>
</div>
<div class="section" id="register-misc-device-in-the-bex-misc-probe-function">
<h3>5. Register misc device in the bex_misc probe function<a class="headerlink" href="#register-misc-device-in-the-bex-misc-probe-function" title="Permalink to this headline">¶</a></h3>
<p>Modify <strong>bex.c</strong> to refuse probing for versions &gt; 1. Also register the
defined misc device in bex_misc_probe and deregister it in
bex_misc_remove. Follow the <strong>TODO 6</strong> markings.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use <code class="xref c c-func docutils literal"><span class="pre">misc_register()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">misc_deregister()</span></code>.</p>
</div>
<p>Create a new device with the name “test”, type “misc” and version 2
and observe that the probe fails. Create a new device with the name
“test”, type “misc” and version 1 and observe that the probe is
succesfull.</p>
<p>Inspect the /sys/bus/bex/devices/test and observe that we have a new
entry. Identify the major and minor for the misc device, create a
character device file and try to read and write from the misc device
buffer.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The major and minor should be visible in the dev attribute
of the misc device</p>
</div>
</div>
<div class="section" id="monitor-uevent-notifications">
<h3>6. Monitor uevent notifications<a class="headerlink" href="#monitor-uevent-notifications" title="Permalink to this headline">¶</a></h3>
<p>Use the <strong>udevadm monitor</strong> command and observe what happens when:</p>
<ul class="simple">
<li>the bex.ko and bex_misc.ko modeules are inserted</li>
<li>a new device with the type “test” is created</li>
<li>a new device with the type “misc” and version 2 is created</li>
<li>a new device with the type “misc” and version 1 is created</li>
<li>all of the above devices are removed</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../info/vm.html" class="btn btn-neutral float-right" title="Virtual Machine Setup" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="memory_mapping.html" class="btn btn-neutral float-left" title="Memory mapping" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>